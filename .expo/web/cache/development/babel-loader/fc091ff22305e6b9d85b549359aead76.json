{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport InlineWorker from 'inline-worker';\nexport var Recorder = function () {\n  function Recorder(source, cfg) {\n    var _this = this;\n\n    _classCallCheck(this, Recorder);\n\n    this.config = _objectSpread({\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav'\n    }, cfg);\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels);\n\n    this.node.onaudioprocess = function (e) {\n      if (!_this.recording) return;\n      var buffer = [];\n\n      for (var channel = 0; channel < _this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n\n      _this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination);\n    var self = {};\n    this.worker = new InlineWorker(function () {\n      var recLength = 0,\n          recBuffers = [],\n          sampleRate,\n          numChannels;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n\n          case 'record':\n            record(e.data.buffer);\n            break;\n\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n\n          case 'getBuffer':\n            getBuffer();\n            break;\n\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      var newSampleRate;\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        var buffers = [];\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n\n        var interleaved;\n\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        var downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n        var dataview = encodeWAV(downSampledBuffer);\n        var audioBlob = new Blob([dataview], {\n          type: type\n        });\n        this.postMessage({\n          command: 'exportWAV',\n          data: audioBlob\n        });\n      }\n\n      function getBuffer() {\n        var buffers = [];\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n\n        this.postMessage({\n          command: 'getBuffer',\n          data: buffers\n        });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        var result = new Float32Array(recLength);\n        var offset = 0;\n\n        for (var i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        var length = inputL.length + inputR.length;\n        var result = new Float32Array(length);\n        var index = 0,\n            inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (var i = 0; i < input.length; i++, offset += 2) {\n          var s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (var i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n          var accum = 0,\n              count = 0;\n\n          for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n          }\n\n          result[offsetResult] = accum / count;\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n\n        return result;\n      }\n\n      function encodeWAV(samples) {\n        var buffer = new ArrayBuffer(44 + samples.length * 2);\n        var view = new DataView(buffer);\n        writeString(view, 0, 'RIFF');\n        view.setUint32(4, 36 + samples.length * 2, true);\n        writeString(view, 8, 'WAVE');\n        writeString(view, 12, 'fmt ');\n        view.setUint32(16, 16, true);\n        view.setUint16(20, 1, true);\n        view.setUint16(22, numChannels, true);\n        view.setUint32(24, newSampleRate, true);\n        view.setUint32(28, newSampleRate * 4, true);\n        view.setUint16(32, numChannels * 2, true);\n        view.setUint16(34, 16, true);\n        writeString(view, 36, 'data');\n        view.setUint32(40, samples.length * 2, true);\n        floatTo16BitPCM(view, 44, samples);\n        return view;\n      }\n    }, self);\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = function (e) {\n      var cb = _this.callbacks[e.data.command].pop();\n\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  _createClass(Recorder, [{\n    key: \"record\",\n    value: function record() {\n      this.recording = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.recording = false;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.worker.postMessage({\n        command: 'clear'\n      });\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(cb) {\n      cb = cb || this.config.callback;\n      if (!cb) throw new Error('Callback not set');\n      this.callbacks.getBuffer.push(cb);\n      this.worker.postMessage({\n        command: 'getBuffer'\n      });\n    }\n  }, {\n    key: \"exportWAV\",\n    value: function exportWAV(cb, mimeType) {\n      mimeType = mimeType || this.config.mimeType;\n      cb = cb || this.config.callback;\n      if (!cb) throw new Error('Callback not set');\n      this.callbacks.exportWAV.push(cb);\n      this.worker.postMessage({\n        command: 'exportWAV',\n        type: mimeType\n      });\n    }\n  }], [{\n    key: \"forceDownload\",\n    value: function forceDownload(blob, filename) {\n      var url = (window.URL || window.webkitURL).createObjectURL(blob);\n      var link = window.document.createElement('a');\n      link.href = url;\n      link.download = filename || 'output.wav';\n      var click = document.createEvent('Event');\n      click.initEvent('click', true, true);\n      link.dispatchEvent(click);\n    }\n  }]);\n\n  return Recorder;\n}();\nexport default Recorder;","map":{"version":3,"names":["InlineWorker","Recorder","source","cfg","config","bufferLen","numChannels","mimeType","recording","callbacks","getBuffer","exportWAV","context","node","createScriptProcessor","createJavaScriptNode","call","onaudioprocess","e","buffer","channel","push","inputBuffer","getChannelData","worker","postMessage","command","connect","destination","self","recLength","recBuffers","sampleRate","onmessage","data","init","record","type","clear","newSampleRate","initBuffers","length","buffers","mergeBuffers","interleaved","interleave","downSampledBuffer","downSampleBuffer","dataview","encodeWAV","audioBlob","Blob","result","Float32Array","offset","i","set","inputL","inputR","index","inputIndex","floatTo16BitPCM","output","input","s","Math","max","min","setInt16","writeString","view","string","setUint8","charCodeAt","rate","sampleRateRatio","newLength","round","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","samples","ArrayBuffer","DataView","setUint32","setUint16","cb","pop","callback","Error","blob","filename","url","window","URL","webkitURL","createObjectURL","link","document","createElement","href","download","click","createEvent","initEvent","dispatchEvent"],"sources":["/Users/sandeepjain/Routine-Remind/screens/StudentScreen/Hooks/recorder.js"],"sourcesContent":["import InlineWorker from 'inline-worker';\n\nexport class Recorder {\n  constructor(source, cfg) {\n    this.config = {\n      bufferLen: 4096,\n      numChannels: 1,\n      mimeType: 'audio/wav',\n      ...cfg\n    };\n    this.recording = false;\n    this.callbacks = {\n      getBuffer: [],\n      exportWAV: []\n    };\n    this.context = source.context;\n    this.node = (\n      this.context.createScriptProcessor || this.context.createJavaScriptNode\n    ).call(\n      this.context,\n      this.config.bufferLen,\n      this.config.numChannels,\n      this.config.numChannels\n    );\n\n    this.node.onaudioprocess = (e) => {\n      if (!this.recording) return;\n\n      var buffer = [];\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\n        buffer.push(e.inputBuffer.getChannelData(channel));\n      }\n      this.worker.postMessage({\n        command: 'record',\n        buffer: buffer\n      });\n    };\n\n    source.connect(this.node);\n    this.node.connect(this.context.destination); //this should not be necessary\n\n    let self = {};\n    this.worker = new InlineWorker(function () {\n      let recLength = 0,\n        recBuffers = [],\n        sampleRate,\n        numChannels;\n\n      this.onmessage = function (e) {\n        switch (e.data.command) {\n          case 'init':\n            init(e.data.config);\n            break;\n          case 'record':\n            record(e.data.buffer);\n            break;\n          case 'exportWAV':\n            exportWAV(e.data.type);\n            break;\n          case 'getBuffer':\n            getBuffer();\n            break;\n          case 'clear':\n            clear();\n            break;\n        }\n      };\n\n      let newSampleRate;\n\n      function init(config) {\n        sampleRate = config.sampleRate;\n        numChannels = config.numChannels;\n        initBuffers();\n\n        if (sampleRate > 48000) {\n          newSampleRate = 48000;\n        } else {\n          newSampleRate = sampleRate;\n        }\n      }\n\n      function record(inputBuffer) {\n        for (var channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel].push(inputBuffer[channel]);\n        }\n        recLength += inputBuffer[0].length;\n      }\n\n      function exportWAV(type) {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        let interleaved;\n        if (numChannels === 2) {\n          interleaved = interleave(buffers[0], buffers[1]);\n        } else {\n          interleaved = buffers[0];\n        }\n\n        // converts sample rate to 48000 if higher than 48000\n        let downSampledBuffer = downSampleBuffer(interleaved, newSampleRate);\n\n        let dataview = encodeWAV(downSampledBuffer);\n        let audioBlob = new Blob([dataview], { type: type });\n\n        this.postMessage({ command: 'exportWAV', data: audioBlob });\n      }\n\n      function getBuffer() {\n        let buffers = [];\n        for (let channel = 0; channel < numChannels; channel++) {\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\n        }\n        this.postMessage({ command: 'getBuffer', data: buffers });\n      }\n\n      function clear() {\n        recLength = 0;\n        recBuffers = [];\n        initBuffers();\n      }\n\n      function initBuffers() {\n        for (let channel = 0; channel < numChannels; channel++) {\n          recBuffers[channel] = [];\n        }\n      }\n\n      function mergeBuffers(recBuffers, recLength) {\n        let result = new Float32Array(recLength);\n        let offset = 0;\n        for (let i = 0; i < recBuffers.length; i++) {\n          result.set(recBuffers[i], offset);\n          offset += recBuffers[i].length;\n        }\n        return result;\n      }\n\n      function interleave(inputL, inputR) {\n        let length = inputL.length + inputR.length;\n        let result = new Float32Array(length);\n\n        let index = 0,\n          inputIndex = 0;\n\n        while (index < length) {\n          result[index++] = inputL[inputIndex];\n          result[index++] = inputR[inputIndex];\n          inputIndex++;\n        }\n        return result;\n      }\n\n      function floatTo16BitPCM(output, offset, input) {\n        for (let i = 0; i < input.length; i++, offset += 2) {\n          let s = Math.max(-1, Math.min(1, input[i]));\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n        }\n      }\n\n      function writeString(view, offset, string) {\n        for (let i = 0; i < string.length; i++) {\n          view.setUint8(offset + i, string.charCodeAt(i));\n        }\n      }\n\n      // Down sample buffer before WAV encoding\n      function downSampleBuffer(buffer, rate) {\n        if (rate == sampleRate) {\n          return buffer;\n        }\n        if (rate > sampleRate) {\n          throw 'downsampling rate show be smaller than original sample rate';\n        }\n        var sampleRateRatio = sampleRate / rate;\n        var newLength = Math.round(buffer.length / sampleRateRatio);\n        var result = new Float32Array(newLength);\n        var offsetResult = 0;\n        var offsetBuffer = 0;\n        while (offsetResult < result.length) {\n          var nextOffsetBuffer = Math.round(\n            (offsetResult + 1) * sampleRateRatio\n          );\n          // Use average value of skipped samples\n          var accum = 0,\n            count = 0;\n          for (\n            var i = offsetBuffer;\n            i < nextOffsetBuffer && i < buffer.length;\n            i++\n          ) {\n            accum += buffer[i];\n            count++;\n          }\n          result[offsetResult] = accum / count;\n          // Or you can simply get rid of the skipped samples:\n          // result[offsetResult] = buffer[nextOffsetBuffer];\n          offsetResult++;\n          offsetBuffer = nextOffsetBuffer;\n        }\n        return result;\n      }\n\n      function encodeWAV(samples) {\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\n        let view = new DataView(buffer);\n\n        /* RIFF identifier */\n        writeString(view, 0, 'RIFF');\n        /* RIFF chunk length */\n        view.setUint32(4, 36 + samples.length * 2, true);\n        /* RIFF type */\n        writeString(view, 8, 'WAVE');\n        /* format chunk identifier */\n        writeString(view, 12, 'fmt ');\n        /* format chunk length */\n        view.setUint32(16, 16, true);\n        /* sample format (raw) */\n        view.setUint16(20, 1, true);\n        /* channel count */\n        view.setUint16(22, numChannels, true);\n        /* sample rate */\n        view.setUint32(24, newSampleRate, true);\n        /* byte rate (sample rate * block align) */\n        view.setUint32(28, newSampleRate * 4, true);\n        /* block align (channel count * bytes per sample) */\n        view.setUint16(32, numChannels * 2, true);\n        /* bits per sample */\n        view.setUint16(34, 16, true);\n        /* data chunk identifier */\n        writeString(view, 36, 'data');\n        /* data chunk length */\n        view.setUint32(40, samples.length * 2, true);\n\n        floatTo16BitPCM(view, 44, samples);\n\n        return view;\n      }\n    }, self);\n\n    this.worker.postMessage({\n      command: 'init',\n      config: {\n        sampleRate: this.context.sampleRate,\n        numChannels: this.config.numChannels\n      }\n    });\n\n    this.worker.onmessage = (e) => {\n      let cb = this.callbacks[e.data.command].pop();\n      if (typeof cb == 'function') {\n        cb(e.data.data);\n      }\n    };\n  }\n\n  record() {\n    this.recording = true;\n  }\n\n  stop() {\n    this.recording = false;\n  }\n\n  clear() {\n    this.worker.postMessage({ command: 'clear' });\n  }\n\n  getBuffer(cb) {\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.getBuffer.push(cb);\n\n    this.worker.postMessage({ command: 'getBuffer' });\n  }\n\n  exportWAV(cb, mimeType) {\n    mimeType = mimeType || this.config.mimeType;\n    cb = cb || this.config.callback;\n    if (!cb) throw new Error('Callback not set');\n\n    this.callbacks.exportWAV.push(cb);\n\n    this.worker.postMessage({\n      command: 'exportWAV',\n      type: mimeType\n    });\n  }\n\n  static forceDownload(blob, filename) {\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\n    let link = window.document.createElement('a');\n    link.href = url;\n    link.download = filename || 'output.wav';\n    let click = document.createEvent('Event');\n    click.initEvent('click', true, true);\n    link.dispatchEvent(click);\n  }\n}\n\nexport default Recorder;\n"],"mappings":";;;;;;;;AAAA,OAAOA,YAAP,MAAyB,eAAzB;AAEA,WAAaC,QAAb;EACE,kBAAYC,MAAZ,EAAoBC,GAApB,EAAyB;IAAA;;IAAA;;IACvB,KAAKC,MAAL;MACEC,SAAS,EAAE,IADb;MAEEC,WAAW,EAAE,CAFf;MAGEC,QAAQ,EAAE;IAHZ,GAIKJ,GAJL;IAMA,KAAKK,SAAL,GAAiB,KAAjB;IACA,KAAKC,SAAL,GAAiB;MACfC,SAAS,EAAE,EADI;MAEfC,SAAS,EAAE;IAFI,CAAjB;IAIA,KAAKC,OAAL,GAAeV,MAAM,CAACU,OAAtB;IACA,KAAKC,IAAL,GAAY,CACV,KAAKD,OAAL,CAAaE,qBAAb,IAAsC,KAAKF,OAAL,CAAaG,oBADzC,EAEVC,IAFU,CAGV,KAAKJ,OAHK,EAIV,KAAKR,MAAL,CAAYC,SAJF,EAKV,KAAKD,MAAL,CAAYE,WALF,EAMV,KAAKF,MAAL,CAAYE,WANF,CAAZ;;IASA,KAAKO,IAAL,CAAUI,cAAV,GAA2B,UAACC,CAAD,EAAO;MAChC,IAAI,CAAC,KAAI,CAACV,SAAV,EAAqB;MAErB,IAAIW,MAAM,GAAG,EAAb;;MACA,KAAK,IAAIC,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAG,KAAI,CAAChB,MAAL,CAAYE,WAA5C,EAAyDc,OAAO,EAAhE,EAAoE;QAClED,MAAM,CAACE,IAAP,CAAYH,CAAC,CAACI,WAAF,CAAcC,cAAd,CAA6BH,OAA7B,CAAZ;MACD;;MACD,KAAI,CAACI,MAAL,CAAYC,WAAZ,CAAwB;QACtBC,OAAO,EAAE,QADa;QAEtBP,MAAM,EAAEA;MAFc,CAAxB;IAID,CAXD;;IAaAjB,MAAM,CAACyB,OAAP,CAAe,KAAKd,IAApB;IACA,KAAKA,IAAL,CAAUc,OAAV,CAAkB,KAAKf,OAAL,CAAagB,WAA/B;IAEA,IAAIC,IAAI,GAAG,EAAX;IACA,KAAKL,MAAL,GAAc,IAAIxB,YAAJ,CAAiB,YAAY;MACzC,IAAI8B,SAAS,GAAG,CAAhB;MAAA,IACEC,UAAU,GAAG,EADf;MAAA,IAEEC,UAFF;MAAA,IAGE1B,WAHF;;MAKA,KAAK2B,SAAL,GAAiB,UAAUf,CAAV,EAAa;QAC5B,QAAQA,CAAC,CAACgB,IAAF,CAAOR,OAAf;UACE,KAAK,MAAL;YACES,IAAI,CAACjB,CAAC,CAACgB,IAAF,CAAO9B,MAAR,CAAJ;YACA;;UACF,KAAK,QAAL;YACEgC,MAAM,CAAClB,CAAC,CAACgB,IAAF,CAAOf,MAAR,CAAN;YACA;;UACF,KAAK,WAAL;YACER,SAAS,CAACO,CAAC,CAACgB,IAAF,CAAOG,IAAR,CAAT;YACA;;UACF,KAAK,WAAL;YACE3B,SAAS;YACT;;UACF,KAAK,OAAL;YACE4B,KAAK;YACL;QAfJ;MAiBD,CAlBD;;MAoBA,IAAIC,aAAJ;;MAEA,SAASJ,IAAT,CAAc/B,MAAd,EAAsB;QACpB4B,UAAU,GAAG5B,MAAM,CAAC4B,UAApB;QACA1B,WAAW,GAAGF,MAAM,CAACE,WAArB;QACAkC,WAAW;;QAEX,IAAIR,UAAU,GAAG,KAAjB,EAAwB;UACtBO,aAAa,GAAG,KAAhB;QACD,CAFD,MAEO;UACLA,aAAa,GAAGP,UAAhB;QACD;MACF;;MAED,SAASI,MAAT,CAAgBd,WAAhB,EAA6B;QAC3B,KAAK,IAAIF,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGd,WAAhC,EAA6Cc,OAAO,EAApD,EAAwD;UACtDW,UAAU,CAACX,OAAD,CAAV,CAAoBC,IAApB,CAAyBC,WAAW,CAACF,OAAD,CAApC;QACD;;QACDU,SAAS,IAAIR,WAAW,CAAC,CAAD,CAAX,CAAemB,MAA5B;MACD;;MAED,SAAS9B,SAAT,CAAmB0B,IAAnB,EAAyB;QACvB,IAAIK,OAAO,GAAG,EAAd;;QACA,KAAK,IAAItB,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGd,WAAhC,EAA6Cc,OAAO,EAApD,EAAwD;UACtDsB,OAAO,CAACrB,IAAR,CAAasB,YAAY,CAACZ,UAAU,CAACX,OAAD,CAAX,EAAsBU,SAAtB,CAAzB;QACD;;QACD,IAAIc,WAAJ;;QACA,IAAItC,WAAW,KAAK,CAApB,EAAuB;UACrBsC,WAAW,GAAGC,UAAU,CAACH,OAAO,CAAC,CAAD,CAAR,EAAaA,OAAO,CAAC,CAAD,CAApB,CAAxB;QACD,CAFD,MAEO;UACLE,WAAW,GAAGF,OAAO,CAAC,CAAD,CAArB;QACD;;QAGD,IAAII,iBAAiB,GAAGC,gBAAgB,CAACH,WAAD,EAAcL,aAAd,CAAxC;QAEA,IAAIS,QAAQ,GAAGC,SAAS,CAACH,iBAAD,CAAxB;QACA,IAAII,SAAS,GAAG,IAAIC,IAAJ,CAAS,CAACH,QAAD,CAAT,EAAqB;UAAEX,IAAI,EAAEA;QAAR,CAArB,CAAhB;QAEA,KAAKZ,WAAL,CAAiB;UAAEC,OAAO,EAAE,WAAX;UAAwBQ,IAAI,EAAEgB;QAA9B,CAAjB;MACD;;MAED,SAASxC,SAAT,GAAqB;QACnB,IAAIgC,OAAO,GAAG,EAAd;;QACA,KAAK,IAAItB,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGd,WAAhC,EAA6Cc,OAAO,EAApD,EAAwD;UACtDsB,OAAO,CAACrB,IAAR,CAAasB,YAAY,CAACZ,UAAU,CAACX,OAAD,CAAX,EAAsBU,SAAtB,CAAzB;QACD;;QACD,KAAKL,WAAL,CAAiB;UAAEC,OAAO,EAAE,WAAX;UAAwBQ,IAAI,EAAEQ;QAA9B,CAAjB;MACD;;MAED,SAASJ,KAAT,GAAiB;QACfR,SAAS,GAAG,CAAZ;QACAC,UAAU,GAAG,EAAb;QACAS,WAAW;MACZ;;MAED,SAASA,WAAT,GAAuB;QACrB,KAAK,IAAIpB,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGd,WAAhC,EAA6Cc,OAAO,EAApD,EAAwD;UACtDW,UAAU,CAACX,OAAD,CAAV,GAAsB,EAAtB;QACD;MACF;;MAED,SAASuB,YAAT,CAAsBZ,UAAtB,EAAkCD,SAAlC,EAA6C;QAC3C,IAAIsB,MAAM,GAAG,IAAIC,YAAJ,CAAiBvB,SAAjB,CAAb;QACA,IAAIwB,MAAM,GAAG,CAAb;;QACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxB,UAAU,CAACU,MAA/B,EAAuCc,CAAC,EAAxC,EAA4C;UAC1CH,MAAM,CAACI,GAAP,CAAWzB,UAAU,CAACwB,CAAD,CAArB,EAA0BD,MAA1B;UACAA,MAAM,IAAIvB,UAAU,CAACwB,CAAD,CAAV,CAAcd,MAAxB;QACD;;QACD,OAAOW,MAAP;MACD;;MAED,SAASP,UAAT,CAAoBY,MAApB,EAA4BC,MAA5B,EAAoC;QAClC,IAAIjB,MAAM,GAAGgB,MAAM,CAAChB,MAAP,GAAgBiB,MAAM,CAACjB,MAApC;QACA,IAAIW,MAAM,GAAG,IAAIC,YAAJ,CAAiBZ,MAAjB,CAAb;QAEA,IAAIkB,KAAK,GAAG,CAAZ;QAAA,IACEC,UAAU,GAAG,CADf;;QAGA,OAAOD,KAAK,GAAGlB,MAAf,EAAuB;UACrBW,MAAM,CAACO,KAAK,EAAN,CAAN,GAAkBF,MAAM,CAACG,UAAD,CAAxB;UACAR,MAAM,CAACO,KAAK,EAAN,CAAN,GAAkBD,MAAM,CAACE,UAAD,CAAxB;UACAA,UAAU;QACX;;QACD,OAAOR,MAAP;MACD;;MAED,SAASS,eAAT,CAAyBC,MAAzB,EAAiCR,MAAjC,EAAyCS,KAAzC,EAAgD;QAC9C,KAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,KAAK,CAACtB,MAA1B,EAAkCc,CAAC,IAAID,MAAM,IAAI,CAAjD,EAAoD;UAClD,IAAIU,CAAC,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAC,CAAV,EAAaD,IAAI,CAACE,GAAL,CAAS,CAAT,EAAYJ,KAAK,CAACR,CAAD,CAAjB,CAAb,CAAR;UACAO,MAAM,CAACM,QAAP,CAAgBd,MAAhB,EAAwBU,CAAC,GAAG,CAAJ,GAAQA,CAAC,GAAG,MAAZ,GAAqBA,CAAC,GAAG,MAAjD,EAAyD,IAAzD;QACD;MACF;;MAED,SAASK,WAAT,CAAqBC,IAArB,EAA2BhB,MAA3B,EAAmCiB,MAAnC,EAA2C;QACzC,KAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,MAAM,CAAC9B,MAA3B,EAAmCc,CAAC,EAApC,EAAwC;UACtCe,IAAI,CAACE,QAAL,CAAclB,MAAM,GAAGC,CAAvB,EAA0BgB,MAAM,CAACE,UAAP,CAAkBlB,CAAlB,CAA1B;QACD;MACF;;MAGD,SAASR,gBAAT,CAA0B5B,MAA1B,EAAkCuD,IAAlC,EAAwC;QACtC,IAAIA,IAAI,IAAI1C,UAAZ,EAAwB;UACtB,OAAOb,MAAP;QACD;;QACD,IAAIuD,IAAI,GAAG1C,UAAX,EAAuB;UACrB,MAAM,6DAAN;QACD;;QACD,IAAI2C,eAAe,GAAG3C,UAAU,GAAG0C,IAAnC;QACA,IAAIE,SAAS,GAAGX,IAAI,CAACY,KAAL,CAAW1D,MAAM,CAACsB,MAAP,GAAgBkC,eAA3B,CAAhB;QACA,IAAIvB,MAAM,GAAG,IAAIC,YAAJ,CAAiBuB,SAAjB,CAAb;QACA,IAAIE,YAAY,GAAG,CAAnB;QACA,IAAIC,YAAY,GAAG,CAAnB;;QACA,OAAOD,YAAY,GAAG1B,MAAM,CAACX,MAA7B,EAAqC;UACnC,IAAIuC,gBAAgB,GAAGf,IAAI,CAACY,KAAL,CACrB,CAACC,YAAY,GAAG,CAAhB,IAAqBH,eADA,CAAvB;UAIA,IAAIM,KAAK,GAAG,CAAZ;UAAA,IACEC,KAAK,GAAG,CADV;;UAEA,KACE,IAAI3B,CAAC,GAAGwB,YADV,EAEExB,CAAC,GAAGyB,gBAAJ,IAAwBzB,CAAC,GAAGpC,MAAM,CAACsB,MAFrC,EAGEc,CAAC,EAHH,EAIE;YACA0B,KAAK,IAAI9D,MAAM,CAACoC,CAAD,CAAf;YACA2B,KAAK;UACN;;UACD9B,MAAM,CAAC0B,YAAD,CAAN,GAAuBG,KAAK,GAAGC,KAA/B;UAGAJ,YAAY;UACZC,YAAY,GAAGC,gBAAf;QACD;;QACD,OAAO5B,MAAP;MACD;;MAED,SAASH,SAAT,CAAmBkC,OAAnB,EAA4B;QAC1B,IAAIhE,MAAM,GAAG,IAAIiE,WAAJ,CAAgB,KAAKD,OAAO,CAAC1C,MAAR,GAAiB,CAAtC,CAAb;QACA,IAAI6B,IAAI,GAAG,IAAIe,QAAJ,CAAalE,MAAb,CAAX;QAGAkD,WAAW,CAACC,IAAD,EAAO,CAAP,EAAU,MAAV,CAAX;QAEAA,IAAI,CAACgB,SAAL,CAAe,CAAf,EAAkB,KAAKH,OAAO,CAAC1C,MAAR,GAAiB,CAAxC,EAA2C,IAA3C;QAEA4B,WAAW,CAACC,IAAD,EAAO,CAAP,EAAU,MAAV,CAAX;QAEAD,WAAW,CAACC,IAAD,EAAO,EAAP,EAAW,MAAX,CAAX;QAEAA,IAAI,CAACgB,SAAL,CAAe,EAAf,EAAmB,EAAnB,EAAuB,IAAvB;QAEAhB,IAAI,CAACiB,SAAL,CAAe,EAAf,EAAmB,CAAnB,EAAsB,IAAtB;QAEAjB,IAAI,CAACiB,SAAL,CAAe,EAAf,EAAmBjF,WAAnB,EAAgC,IAAhC;QAEAgE,IAAI,CAACgB,SAAL,CAAe,EAAf,EAAmB/C,aAAnB,EAAkC,IAAlC;QAEA+B,IAAI,CAACgB,SAAL,CAAe,EAAf,EAAmB/C,aAAa,GAAG,CAAnC,EAAsC,IAAtC;QAEA+B,IAAI,CAACiB,SAAL,CAAe,EAAf,EAAmBjF,WAAW,GAAG,CAAjC,EAAoC,IAApC;QAEAgE,IAAI,CAACiB,SAAL,CAAe,EAAf,EAAmB,EAAnB,EAAuB,IAAvB;QAEAlB,WAAW,CAACC,IAAD,EAAO,EAAP,EAAW,MAAX,CAAX;QAEAA,IAAI,CAACgB,SAAL,CAAe,EAAf,EAAmBH,OAAO,CAAC1C,MAAR,GAAiB,CAApC,EAAuC,IAAvC;QAEAoB,eAAe,CAACS,IAAD,EAAO,EAAP,EAAWa,OAAX,CAAf;QAEA,OAAOb,IAAP;MACD;IACF,CAtMa,EAsMXzC,IAtMW,CAAd;IAwMA,KAAKL,MAAL,CAAYC,WAAZ,CAAwB;MACtBC,OAAO,EAAE,MADa;MAEtBtB,MAAM,EAAE;QACN4B,UAAU,EAAE,KAAKpB,OAAL,CAAaoB,UADnB;QAEN1B,WAAW,EAAE,KAAKF,MAAL,CAAYE;MAFnB;IAFc,CAAxB;;IAQA,KAAKkB,MAAL,CAAYS,SAAZ,GAAwB,UAACf,CAAD,EAAO;MAC7B,IAAIsE,EAAE,GAAG,KAAI,CAAC/E,SAAL,CAAeS,CAAC,CAACgB,IAAF,CAAOR,OAAtB,EAA+B+D,GAA/B,EAAT;;MACA,IAAI,OAAOD,EAAP,IAAa,UAAjB,EAA6B;QAC3BA,EAAE,CAACtE,CAAC,CAACgB,IAAF,CAAOA,IAAR,CAAF;MACD;IACF,CALD;EAMD;;EA9PH;IAAA;IAAA,OAgQE,kBAAS;MACP,KAAK1B,SAAL,GAAiB,IAAjB;IACD;EAlQH;IAAA;IAAA,OAoQE,gBAAO;MACL,KAAKA,SAAL,GAAiB,KAAjB;IACD;EAtQH;IAAA;IAAA,OAwQE,iBAAQ;MACN,KAAKgB,MAAL,CAAYC,WAAZ,CAAwB;QAAEC,OAAO,EAAE;MAAX,CAAxB;IACD;EA1QH;IAAA;IAAA,OA4QE,mBAAU8D,EAAV,EAAc;MACZA,EAAE,GAAGA,EAAE,IAAI,KAAKpF,MAAL,CAAYsF,QAAvB;MACA,IAAI,CAACF,EAAL,EAAS,MAAM,IAAIG,KAAJ,CAAU,kBAAV,CAAN;MAET,KAAKlF,SAAL,CAAeC,SAAf,CAAyBW,IAAzB,CAA8BmE,EAA9B;MAEA,KAAKhE,MAAL,CAAYC,WAAZ,CAAwB;QAAEC,OAAO,EAAE;MAAX,CAAxB;IACD;EAnRH;IAAA;IAAA,OAqRE,mBAAU8D,EAAV,EAAcjF,QAAd,EAAwB;MACtBA,QAAQ,GAAGA,QAAQ,IAAI,KAAKH,MAAL,CAAYG,QAAnC;MACAiF,EAAE,GAAGA,EAAE,IAAI,KAAKpF,MAAL,CAAYsF,QAAvB;MACA,IAAI,CAACF,EAAL,EAAS,MAAM,IAAIG,KAAJ,CAAU,kBAAV,CAAN;MAET,KAAKlF,SAAL,CAAeE,SAAf,CAAyBU,IAAzB,CAA8BmE,EAA9B;MAEA,KAAKhE,MAAL,CAAYC,WAAZ,CAAwB;QACtBC,OAAO,EAAE,WADa;QAEtBW,IAAI,EAAE9B;MAFgB,CAAxB;IAID;EAhSH;IAAA;IAAA,OAkSE,uBAAqBqF,IAArB,EAA2BC,QAA3B,EAAqC;MACnC,IAAIC,GAAG,GAAG,CAACC,MAAM,CAACC,GAAP,IAAcD,MAAM,CAACE,SAAtB,EAAiCC,eAAjC,CAAiDN,IAAjD,CAAV;MACA,IAAIO,IAAI,GAAGJ,MAAM,CAACK,QAAP,CAAgBC,aAAhB,CAA8B,GAA9B,CAAX;MACAF,IAAI,CAACG,IAAL,GAAYR,GAAZ;MACAK,IAAI,CAACI,QAAL,GAAgBV,QAAQ,IAAI,YAA5B;MACA,IAAIW,KAAK,GAAGJ,QAAQ,CAACK,WAAT,CAAqB,OAArB,CAAZ;MACAD,KAAK,CAACE,SAAN,CAAgB,OAAhB,EAAyB,IAAzB,EAA+B,IAA/B;MACAP,IAAI,CAACQ,aAAL,CAAmBH,KAAnB;IACD;EA1SH;;EAAA;AAAA;AA6SA,eAAevG,QAAf"},"metadata":{},"sourceType":"module"}